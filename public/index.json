[{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"https://zztracy.github.io/posts/jvm/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"https://zztracy.github.io/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"https://zztracy.github.io/posts/redis/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis 中，Dict 是一种核心的数据结构，用于实现键值对（key-value）存储。它是 redis 高效运行的基础之一。在数据库的键空间、Hash 数据类型、有序集合等场景均存在应用。\nDict的数据结构 Dict由三部分组成：\n哈希表节点：dictEntry，表示一个键值对；包含key、value 以及指向下一个节点的指针 哈希表：dictht，包含一个 dictEntry 指针数组，用于存储键值对，以及记录哈希表的大小，已用节点数等信息 字典：dict，包含两个哈希表（ht[0] 和 ht[1]），这样的设计能够支持渐进式 rehash # dict.h typedef struct dictEntry { void *key; // 键 union { void *val; uint64_t u64; int64_t s64; double d; } v; // 下一个Entry的指针 struct dictEntry *next; } dictEntry; # dict.h typedef struct dictht { // 哈希表数组，每个元素都是指向 dictEntry 的指针 dictEntry **table; // 哈希表的大小，即table 数组的长度 unsigned long size; // 哈希表大小掩码，用于计算索引，值为 size-1 unsigned long sizemark; // 已使用的哈希表节点数量 unsigned long used; } dictht; // dict.h typedef struct dict { dictType *type; // dict类型，内置不同的hash函数 void *privadata; // 私有数据，在做特殊hash运行的时候用 dictht ht[2]; // 一个dict包含两个hash表，其中一个是当前数据，另外一个一般为空，rehash的时候使用 long rehashidx; // rehash的进度，-1标识未执行 int16_t pausereshah; // rehash是否暂停，1为暂停，0为继续 } dict; 2 Dict的扩容 Dict中的HashTable就是数组结合单向链表的实践，当集合中元素较多的时候，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。 Dict在每次新增键值对的时候都会检查负载因子（LoadFactor = used/size），满足以下两种情况时会出发哈希表扩容\n哈希表的LoadFactor \u0026gt;= 1，并且服务器没有执行BGSAVE或者是BGREWRITEAOF 等后台进程 哈希表的LoadFactor \u0026gt; 5; static int _dictExpandIfNeeded(dict *d) { // 如果正在rehash中，返回ok if (dictisRehashing(d)) return DICT_OK; // 如果哈希表为空，则初始化哈希表 if (d-\u0026gt;ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE) // 如果哈希表的用量大于哈希表的大小并且 （dict_can_resize || 负载因子 5）进行扩容 // dict_can_resize表示当前没有进行bgrewrite等消耗cpu的操作 if (d-\u0026gt;ht[0].used \u0026gt;= d-\u0026gt;ht[0].size \u0026amp;\u0026amp; (dict_can_resize || d-\u0026gt;ht[0].used/d-\u0026gt;ht[0].size \u0026gt; dict_force_resize_ratio)) { // 扩容大小为used + 1，底层会对扩容大小做判断，实际上找的是第一个大小大于等于 used+1 2 2^n return dictExpand(d, d-\u0026gt;ht[0].used + 1); } return DICT_OK; } 3 Dict的缩容 Dict除了扩容以外，每次删除元素的时候，也会对负载因子做检查，当LoadFactor \u0026lt; 0.1的时候，会做哈希表收缩 Dict删除元素\n// t_hash.c # hashTypeDeleted() if (dictDelete((dict*)o-\u0026gt;ptr, field) == C_OK) { deleted = 1; // 删除成功后，检查是否需要重置Dict的大小，如果需要则调用dictResize方法进行重置 if (htNeedsResize(o-\u0026gt;ptr)) dictResize(o-\u0026gt;ptr); } int dictResize(dict *d) { unsigned long minimal; if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR; // 初始化minimal的值为哈希表的使用量 minimal = d-\u0026gt;ht[0].used; // 如果minimal比初始化容量还小 if (minimal \u0026lt;DICT_HT_INITAL_SIZE) // 将minimal复制为初始化大小 minimal = DICT_HT_INITIAL_SIZE; // 调用dictExpand方法，底层执行的时候是第一个大于等于minimal的2^n return dictExpand(d, minimal); } // server.c int htNeedsResize(dict *dict) { long long size, used; size = dictSlots(dict); used = dictSize(dict); // size \u0026gt; 4 并且负载因子低于0.1的时候需要进行缩容 return (size \u0026gt; DICT_HT_INITIAL_SIZE \u0026amp;\u0026amp; (used * 100/size \u0026lt; HASHTABLE_MIN_FILL)); } 不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask会发生变化，而key的查询与sizemask无关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash\n计算新hash的realSize，值取决于当前要做的是扩容还是收缩 如果是扩容，则size为第一个大于dict.ht[0].used + 1 的2*n 如果是收缩，则新size为第一个大于等于dict.ht[0].used 的 2*n(不得小于4) 按照新的realsize申请内存空间，创建dictht，并且赋值给到dict.ht[1] 设置dict.rehashidx = 0，标志开始rehash 每次执行增删改查操作的时候都对哈希表的一个角标对应的链表的元素进行rehash，然后rehashindex++，直到将所有的数据都rehash完成。这个操作是迁移！！！！不是复制！！！ 将dict.ht[1]赋值给到dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来dict.ht[0]的内存 4 总结 Dict的结构\n类似Java的HashTable，底层是数组加链表来解决哈希冲突 Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash Dict的伸缩 当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容 当LoadFactor小于0.1的时候，Dict收缩 扩容大小为第一个大于等于used + 1的2*n 缩容大小为第一个大于等于used的2*n Dict采用渐进式rehash，每次访问Dict时执行一次rehash rehash时ht[0]只减不增加，新增操作只在ht[1]进行，其他操作在两个哈希表进行 ","permalink":"https://zztracy.github.io/posts/redis/redis-encoding-dict/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis 中，Dict 是一种核心的数据结构，用于实现键值对（key-value）存储。它是 redis 高效运行的基础之一。在数据库的键空间、Hash 数据类型、有序集合等场景均存在应用。\u003c/p\u003e\n\u003ch1 id=\"dict的数据结构\"\u003eDict的数据结构\u003c/h1\u003e\n\u003cp\u003eDict由三部分组成：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e哈希表节点：dictEntry，表示一个键值对；包含key、value 以及指向下一个节点的指针\u003c/li\u003e\n\u003cli\u003e哈希表：dictht，包含一个 dictEntry 指针数组，用于存储键值对，以及记录哈希表的大小，已用节点数等信息\u003c/li\u003e\n\u003cli\u003e字典：dict，包含两个哈希表（ht[0] 和 ht[1]），这样的设计能够支持渐进式 rehash\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# dict.h\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e dictEntry {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ekey; \u003cspan style=\"color:#75715e\"\u003e// 键\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunion\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eval;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003euint64_t\u003c/span\u003e u64;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e s64;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e d;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} v;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#75715e\"\u003e// 下一个Entry的指针\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e dictEntry \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003enext;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} dictEntry;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# dict.h\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e dictht {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 哈希表数组，每个元素都是指向 dictEntry 的指针\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\tdictEntry \u003cspan style=\"color:#f92672\"\u003e**\u003c/span\u003etable;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 哈希表的大小，即table 数组的长度\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e size;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 哈希表大小掩码，用于计算索引，值为 size-1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e sizemark;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 已使用的哈希表节点数量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e used;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} dictht;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// dict.h\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e dict {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tdictType \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003etype; \u003cspan style=\"color:#75715e\"\u003e// dict类型，内置不同的hash函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eprivadata; \u003cspan style=\"color:#75715e\"\u003e// 私有数据，在做特殊hash运行的时候用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\tdictht ht[\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e]; \u003cspan style=\"color:#75715e\"\u003e// 一个dict包含两个hash表，其中一个是当前数据，另外一个一般为空，rehash的时候使用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e rehashidx; \u003cspan style=\"color:#75715e\"\u003e// rehash的进度，-1标识未执行\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint16_t\u003c/span\u003e pausereshah; \u003cspan style=\"color:#75715e\"\u003e// rehash是否暂停，1为暂停，0为继续\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} dict;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-dict的扩容\"\u003e2 Dict的扩容\u003c/h1\u003e\n\u003cp\u003eDict中的HashTable就是数组结合单向链表的实践，当集合中元素较多的时候，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。\nDict在每次新增键值对的时候都会检查负载因子（LoadFactor = used/size），满足以下两种情况时会出发哈希表扩容\u003c/p\u003e","title":"Redis 数据编码 Dict"},{"content":"概述 ZipList 压缩列表。采用了紧凑的数据结构。 ZipList是一种特殊的“双端链表”，由一系列的特殊编码的连续内存块组成。可以在任意一段进行push/pop操作，并且该操作的时间复杂度是O(1)。 如果采用传统的链表方式存储数据的话，单单是一个指针就需要 8 个字节的内存，双端链表的每个节点都需要 2 * 8 个字节的指针来实现。而且链表所占的内存空间不连续，容易造成内存碎片化。\n2 ZipList 的结构 zlbytes 表示 ziplist 的总字节数 zltail 表示最后一个节点与 ziplist 起始地址之间的偏移量 zllen 表示 entry 的节点数量 若干个 entry 节点 zlend ziplist 的结束表示 0xff ![[ziplist 的结构.png]] 双端链表的固定长度 zltypes 4bytes ztail 4bytes zlen 2bytes zlend 1byte 固定需要 11 个字节 entry 节点固定 需要 2 - 10 个字节，加上存储的数据的内容，最小可以去到 3 个字节\n属性 类型 长度 用途 zlbytes unit32_t 4 字节 记录压缩列表占用的字节数，4 个字节能够对4GB 的空间进行寻址了。也就是说理论上一个 ziplist 最大就是 4GB zltail uint32_t 4 字节 记录压缩列表尾节点距离起始地址有多少字节，通过这个偏移量，能够确定尾节点的地址 zlen uint_16 2 字节 记录了压缩列表包含的节点数量。最大值为UINT16_MAX（65534），如果超过这个值，此处会记录为 65535，但是节点的真实数量需要遍历整个压缩列表才能计算得出 entry 列表节点 不定 压缩列表包含各个节点，节点的长度由节点保存的内容决定 zlend uint_8 1 字节 特殊值 0xFF（十进制 255），用于记录压缩列表的末端 3 ZipListEntry的结构 ZipListEntry 中的 Entry 并不像普通链表那样记录前后节点的指针，因为记录两个指针需要占用 16 个字节，浪费内存。而是采用了下面的结构 previous_entry_length | encoding | content\nprevious_entry_length：前一节点的长度，占 1 个或者 5 个字节 如果前一个节点的长度小于 254 字节，则采用 1 个字节来保存这个长度值 如果前一个节点的长度大于 254 字节，则采用 5 个字节来保存这个长度值，第一个字节为0xfe，后面四个字节才是真实的长度数据 encoding：编码属性，记录 content 的数据类型（字符串还是整数）以及长度，占用 1 个、2 个或者 5 个字节 contents：负责保存节点的数据，可以是字符串或者整数 zipListEnrty 的 encoding 编码分为字符串和整数两种 字符串：如果 encoding 是以\u0026quot;00\u0026quot; \u0026ldquo;01\u0026rdquo; 或者“10”开头的，则证明 content 是字符串\n编码 编码长度 字符串大小 | 00pppppp | 1 byte \u0026lt;= 63 bytes | 01pppppp | qqqqqqqq | 2 byte \u0026lt;= 16383 bytes | 10000000 | qqqqqqqq | rrrrrrrr | ssssssss | tttttttt | 5 byte \u0026lt;= 4294967295 bytes 假设现在往一个空的 ziplist 存储字符串 ab、字符串 bc 那么redis 会这么存储 ab： 前一个节点的长度为 0，二进制为 0000 0000，16 进制为 0x00，一个字节 编码，ab 为字符串并且ab 的长度为 2 个字节，因此编码的前两位为 00，补全之后为 0000 0010，16 进制为 0x02，一个字节 内容：a在 utf-8 字符集中的二进制表示为 0110 0001, 16进制为 0x61；b 为 0110 0010, 16进制为 0x62 因此存储 ab 的 entry 在内存中存储为，｜0000 0000 ｜ 0000 0010 ｜ 0110 0001 ｜ 0110 0010｜ 用 16 进制表示则为 0x00 0x02 0x61 0x62 bc：\n前一个节点的长度为 4 个字节，二进制为 0000 0100，16 进制为 0x04 编码，bc 为字符串并且 bc 的长度为 2 个字节，因此编码的前两位为 00，补全之后为 0000 0010, 16进制为 0x02，一个字节 内容：b 在 utf-8 字符集中的二进制表示为 0110 0010; 16进制为0x62, c为 0110 0011，16 进制为 0x63 因此存储 bc 的 entry 在内存中存储为｜ 0000 0100 ｜0000 0010｜0110 0010｜0110 0011｜，用 16 进制表示则为 0x04 0x20 0x62 0x63 整数：如果 encoding 是 11开始的，则证明content 是整数，且 encoding 固定只占用 1 个字节\n编码 编码长度 整数类型 11000000 1 int16_t(2 bytes) 11010000 1 int32_t(4 bytes) 11100000 1 int64_t(8 bytes) 11110000 1 24位有符号整数（3 bytes) 11111110 1 8 位有符号整数（1bytes） 1111xxxx 1 直接在 xxxx 位置保存数值，范围从0000-1101,减1 后结果为实际值 4 ZipList的连锁更新问题 ZipList 的每个 Entry 都包含 previous_entry_length 来记录上一个节点的大小，长度是1 个或者 5 个字节\n如果前一节点的长度小于 254 字节，则采用1 个字节来保存这个长度值 如果前一节点的长度等于 254 字节，则采用 5 个字节来保存这个长度值，第一个字节为 0xfe，后四个字节才是真实长度数据 如果当中有一个字节的数据更新了，超过 254 个字节，那么下一个节点的 previous_entry_length 无法用一个字节记录前一个节点的长度，根据 ziplist entry 的规则，会升级成 5 个字节来存储前一个节点的长度，然后又导致当前 entry 的长度超过 254 个字节，以此类推，导致连锁的大量在 250-254 字节之间的节点长度连锁变化，产生了连锁更新 ![[ziplist 的连锁更新问题.png]]\n5 ZipList 的优缺点 5.1 优点 内存使用高效：ziplist 采用紧凑的内存布局，将所有元素紧密排列在连续的内存块中，不存在额外的指针开销。这使得在存储小数据的时候，能够显著减少内存碎片化，有效节省内存空间。 缓存友好：由于 zipList 元素存储在连续的内存区域，符合计算机的局部原理。当访问一个元素的时候，相邻元素也可能被加载到 cpu 内存中，从而提高数据的访问速度。 5.2 缺点 插入和删除效率低：在 zipList 中进行插入或者删除操作的时候，可能需要对后续的元素进行内存移动，以保持数据的连续性。特别是在列表中间进行删除或者插入操作时，这种内存移动的开销会更大，时间复杂度为 O（n）。 连锁更新问题：ziplist 中的每个节点都包含一个记录前一个节点长度的字段，当某个节点的长度发生变化的时候，可能会影响到后续节点的这个字段，从而导致一系列的更新操作，即连锁更新。连续更新的时间复杂度高。 ","permalink":"https://zztracy.github.io/posts/redis/redis-encoding-ziplist/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003eZipList 压缩列表。采用了紧凑的数据结构。\nZipList是一种特殊的“双端链表”，由一系列的特殊编码的连续内存块组成。可以在任意一段进行push/pop操作，并且该操作的时间复杂度是O(1)。\n如果采用传统的链表方式存储数据的话，单单是一个指针就需要 8 个字节的内存，双端链表的每个节点都需要 2 * 8 个字节的指针来实现。而且链表所占的内存空间不连续，容易造成内存碎片化。\u003c/p\u003e\n\u003ch1 id=\"2-ziplist-的结构\"\u003e2 ZipList 的结构\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003ezlbytes 表示 ziplist 的总字节数\u003c/li\u003e\n\u003cli\u003ezltail 表示最后一个节点与 ziplist 起始地址之间的偏移量\u003c/li\u003e\n\u003cli\u003ezllen 表示 entry 的节点数量\u003c/li\u003e\n\u003cli\u003e若干个 entry 节点\u003c/li\u003e\n\u003cli\u003ezlend ziplist 的结束表示 0xff\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e![[ziplist 的结构.png]]\n双端链表的固定长度\nzltypes 4bytes\nztail 4bytes\nzlen 2bytes\nzlend 1byte\n固定需要 11 个字节\nentry 节点固定 需要 2 - 10 个字节，加上存储的数据的内容，最小可以去到 3 个字节\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e属性\u003c/th\u003e\n          \u003cth\u003e类型\u003c/th\u003e\n          \u003cth\u003e长度\u003c/th\u003e\n          \u003cth\u003e用途\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ezlbytes\u003c/td\u003e\n          \u003ctd\u003eunit32_t\u003c/td\u003e\n          \u003ctd\u003e4 字节\u003c/td\u003e\n          \u003ctd\u003e记录压缩列表占用的字节数，4 个字节能够对4GB 的空间进行寻址了。也就是说理论上一个 ziplist 最大就是 4GB\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ezltail\u003c/td\u003e\n          \u003ctd\u003euint32_t\u003c/td\u003e\n          \u003ctd\u003e4 字节\u003c/td\u003e\n          \u003ctd\u003e记录压缩列表尾节点距离起始地址有多少字节，通过这个偏移量，能够确定尾节点的地址\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ezlen\u003c/td\u003e\n          \u003ctd\u003euint_16\u003c/td\u003e\n          \u003ctd\u003e2 字节\u003c/td\u003e\n          \u003ctd\u003e记录了压缩列表包含的节点数量。最大值为UINT16_MAX（65534），如果超过这个值，此处会记录为 65535，但是节点的真实数量需要遍历整个压缩列表才能计算得出\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eentry\u003c/td\u003e\n          \u003ctd\u003e列表节点\u003c/td\u003e\n          \u003ctd\u003e不定\u003c/td\u003e\n          \u003ctd\u003e压缩列表包含各个节点，节点的长度由节点保存的内容决定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ezlend\u003c/td\u003e\n          \u003ctd\u003euint_8\u003c/td\u003e\n          \u003ctd\u003e1 字节\u003c/td\u003e\n          \u003ctd\u003e特殊值 0xFF（十进制 255），用于记录压缩列表的末端\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch1 id=\"3-ziplistentry的结构\"\u003e3 ZipListEntry的结构\u003c/h1\u003e\n\u003cp\u003eZipListEntry 中的 Entry 并不像普通链表那样记录前后节点的指针，因为记录两个指针需要占用 16 个字节，浪费内存。而是采用了下面的结构\nprevious_entry_length | encoding | content\u003c/p\u003e","title":"Redis 数据编码 ZipList"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length // 如果为负数，prepend 为 1，表示新元素应该插入到集合头部；否则为 0，表示插入到集合尾部 int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); // 重新分配集合的内存，使其能够容纳一个额外的元素· is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); while (length--) // _insetGetEncoded根据旧编码方式获取元素位置 // _intsetSet根据新编码方式插入到新位置 _intsetSet(is, length + prepend, _insetGetEncoded(is, length, curenc)); if (prepend) // 根据 prepend 的值决定将新元素插入到头部还是尾部 _intsetSet(is, 0, value); else _intsetSet(is, intrev32ifbe(is-\u0026gt;length),value); // 更新 intset 的元素长度 is-\u0026gt;length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在只存储少量整数的情况下使用的是 IntSet 编码 通过配置set-max-intset-entries 512可以控制 IntSet 存储的最大元素数量 可以通过 object encoding [key] 命令查看元素的 encoding 如果往set 添加了字符串，在 redis8.0 中，encoding 会变成 listpack 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"https://zztracy.github.io/posts/redis/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"https://zztracy.github.io/posts/redis/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"https://zztracy.github.io/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"}]