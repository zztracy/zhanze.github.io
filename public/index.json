[{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java Stack Frame"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"","permalink":"http://localhost:1313/posts/untitled/","summary":"","title":""},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"","permalink":"http://localhost:1313/posts/redis-encoding-intset/untitled/","summary":"","title":""},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"","title":""},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"1 概述 intSet数据结构的出现是用来存储整数类型的数据的 intSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量 有序，intset会按照元素的升序进行排序 升级，当插入一个超过当前编码范围的整数时，intset会升级\ntypedef struct intset { uint32_t encoding; /* 编码方式，支持16位，32位，64位整数 */ unit32_t length; /* 元素个数 */ int8_t contents[]; /* 整数数组，保存集合数据 */ } intset; contents数组存储的元素本身\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) 2 intset的结构 为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\n![[intset的结构.png]]\n现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"1-概述\"\u003e1 概述\u003c/h1\u003e\n\u003cp\u003eintSet数据结构的出现是用来存储整数类型的数据的\nintSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量\n有序，intset会按照元素的升序进行排序\n升级，当插入一个超过当前编码范围的整数时，intset会升级\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e/* 编码方式，支持16位，32位，64位整数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunit32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e/* 元素个数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e/* 整数数组，保存集合数据 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003econtents数组存储的元素本身\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-intset的结构\"\u003e2 intset的结构\u003c/h1\u003e\n\u003cp\u003e为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\u003c/p\u003e\n\u003cp\u003e![[intset的结构.png]]\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组\u003c/li\u003e\n\u003cli\u003e倒序依次将数组中的元素拷贝到扩容后的正确位置\u003c/li\u003e\n\u003cli\u003e将待添加的元素放到数组的末尾\u003c/li\u003e\n\u003cli\u003e最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eintset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eintsetAdd\u003c/span\u003e(intset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eis, \u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e value, \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e valenc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_intsetValueEncoding\u003c/span\u003e(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e pos;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (valenc \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintre32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e encoding)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetUpgradeAndAdd\u003c/span\u003e(is, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eintsetSearch\u003c/span\u003e(is, value, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003epos)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tis \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetResize\u003c/span\u003e(is, \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (pos \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length)) \u003cspan style=\"color:#a6e22e\"\u003eintsetMoveTail\u003c/span\u003e(is, pos, pos \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e_intsetSet\u003c/span\u003e(is, pos, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tis \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003elength) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"4-应用场景\"\u003e4 应用场景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构\nset-max-intset-entries 512\nredis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\u003cp\u003eIntSet可以看作是特殊的整数数组，具备一些特点\u003c/p\u003e","title":""},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"1 概述 intSet数据结构的出现是用来存储整数类型的数据的 intSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量 有序，intset会按照元素的升序进行排序 升级，当插入一个超过当前编码范围的整数时，intset会升级\ntypedef struct intset { uint32_t encoding; /* 编码方式，支持16位，32位，64位整数 */ unit32_t length; /* 元素个数 */ int8_t contents[]; /* 整数数组，保存集合数据 */ } intset; contents数组存储的元素本身\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) 2 intset的结构 为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\n![[intset的结构.png]]\n现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"1-概述\"\u003e1 概述\u003c/h1\u003e\n\u003cp\u003eintSet数据结构的出现是用来存储整数类型的数据的\nintSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量\n有序，intset会按照元素的升序进行排序\n升级，当插入一个超过当前编码范围的整数时，intset会升级\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e/* 编码方式，支持16位，32位，64位整数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunit32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e/* 元素个数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e/* 整数数组，保存集合数据 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003econtents数组存储的元素本身\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-intset的结构\"\u003e2 intset的结构\u003c/h1\u003e\n\u003cp\u003e为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\u003c/p\u003e\n\u003cp\u003e![[intset的结构.png]]\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组\u003c/li\u003e\n\u003cli\u003e倒序依次将数组中的元素拷贝到扩容后的正确位置\u003c/li\u003e\n\u003cli\u003e将待添加的元素放到数组的末尾\u003c/li\u003e\n\u003cli\u003e最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eintset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eintsetAdd\u003c/span\u003e(intset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eis, \u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e value, \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e valenc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_intsetValueEncoding\u003c/span\u003e(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e pos;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (valenc \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintre32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e encoding)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetUpgradeAndAdd\u003c/span\u003e(is, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eintsetSearch\u003c/span\u003e(is, value, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003epos)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tis \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetResize\u003c/span\u003e(is, \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (pos \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length)) \u003cspan style=\"color:#a6e22e\"\u003eintsetMoveTail\u003c/span\u003e(is, pos, pos \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e_intsetSet\u003c/span\u003e(is, pos, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tis \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003elength) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"4-应用场景\"\u003e4 应用场景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构\nset-max-intset-entries 512\nredis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\u003cp\u003eIntSet可以看作是特殊的整数数组，具备一些特点\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"1 概述 intSet数据结构的出现是用来存储整数类型的数据的 intSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量 有序，intset会按照元素的升序进行排序 升级，当插入一个超过当前编码范围的整数时，intset会升级\ntypedef struct intset { uint32_t encoding; /* 编码方式，支持16位，32位，64位整数 */ unit32_t length; /* 元素个数 */ int8_t contents[]; /* 整数数组，保存集合数据 */ } intset; contents数组存储的元素本身\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) 2 intset的结构 为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\n![[intset的结构.png]]\n现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"1-概述\"\u003e1 概述\u003c/h1\u003e\n\u003cp\u003eintSet数据结构的出现是用来存储整数类型的数据的\nintSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量\n有序，intset会按照元素的升序进行排序\n升级，当插入一个超过当前编码范围的整数时，intset会升级\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e/* 编码方式，支持16位，32位，64位整数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunit32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e/* 元素个数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e/* 整数数组，保存集合数据 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003econtents数组存储的元素本身\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-intset的结构\"\u003e2 intset的结构\u003c/h1\u003e\n\u003cp\u003e为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\u003c/p\u003e\n\u003cp\u003e![[intset的结构.png]]\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组\u003c/li\u003e\n\u003cli\u003e倒序依次将数组中的元素拷贝到扩容后的正确位置\u003c/li\u003e\n\u003cli\u003e将待添加的元素放到数组的末尾\u003c/li\u003e\n\u003cli\u003e最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eintset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eintsetAdd\u003c/span\u003e(intset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eis, \u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e value, \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e valenc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_intsetValueEncoding\u003c/span\u003e(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e pos;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (valenc \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintre32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e encoding)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetUpgradeAndAdd\u003c/span\u003e(is, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eintsetSearch\u003c/span\u003e(is, value, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003epos)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tis \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetResize\u003c/span\u003e(is, \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (pos \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length)) \u003cspan style=\"color:#a6e22e\"\u003eintsetMoveTail\u003c/span\u003e(is, pos, pos \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e_intsetSet\u003c/span\u003e(is, pos, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tis \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003elength) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"4-应用场景\"\u003e4 应用场景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构\nset-max-intset-entries 512\nredis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\u003cp\u003eIntSet可以看作是特殊的整数数组，具备一些特点\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"1 概述 intSet数据结构的出现是用来存储整数类型的数据的 intSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量 有序，intset会按照元素的升序进行排序 升级，当插入一个超过当前编码范围的整数时，intset会升级\ntypedef struct intset { uint32_t encoding; /* 编码方式，支持16位，32位，64位整数 */ unit32_t length; /* 元素个数 */ int8_t contents[]; /* 整数数组，保存集合数据 */ } intset; contents数组存储的元素本身\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) 2 intset的结构 为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\n![[intset的结构.png]]\n现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"1-概述\"\u003e1 概述\u003c/h1\u003e\n\u003cp\u003eintSet数据结构的出现是用来存储整数类型的数据的\nintSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量\n有序，intset会按照元素的升序进行排序\n升级，当插入一个超过当前编码范围的整数时，intset会升级\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e/* 编码方式，支持16位，32位，64位整数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunit32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e/* 元素个数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e/* 整数数组，保存集合数据 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003econtents数组存储的元素本身\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-intset的结构\"\u003e2 intset的结构\u003c/h1\u003e\n\u003cp\u003e为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\u003c/p\u003e\n\u003cp\u003e![[intset的结构.png]]\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组\u003c/li\u003e\n\u003cli\u003e倒序依次将数组中的元素拷贝到扩容后的正确位置\u003c/li\u003e\n\u003cli\u003e将待添加的元素放到数组的末尾\u003c/li\u003e\n\u003cli\u003e最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eintset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eintsetAdd\u003c/span\u003e(intset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eis, \u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e value, \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e valenc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_intsetValueEncoding\u003c/span\u003e(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e pos;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (valenc \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintre32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e encoding)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetUpgradeAndAdd\u003c/span\u003e(is, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eintsetSearch\u003c/span\u003e(is, value, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003epos)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tis \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetResize\u003c/span\u003e(is, \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (pos \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length)) \u003cspan style=\"color:#a6e22e\"\u003eintsetMoveTail\u003c/span\u003e(is, pos, pos \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e_intsetSet\u003c/span\u003e(is, pos, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tis \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003elength) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"4-应用场景\"\u003e4 应用场景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构\nset-max-intset-entries 512\nredis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\u003cp\u003eIntSet可以看作是特殊的整数数组，具备一些特点\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"1 概述 intSet数据结构的出现是用来存储整数类型的数据的 intSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量 有序，intset会按照元素的升序进行排序 升级，当插入一个超过当前编码范围的整数时，intset会升级\ntypedef struct intset { uint32_t encoding; /* 编码方式，支持16位，32位，64位整数 */ unit32_t length; /* 元素个数 */ int8_t contents[]; /* 整数数组，保存集合数据 */ } intset; contents数组存储的元素本身\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) 2 intset的结构 为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\n![[intset的结构.png]]\n现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"1-概述\"\u003e1 概述\u003c/h1\u003e\n\u003cp\u003eintSet数据结构的出现是用来存储整数类型的数据的\nintSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量\n有序，intset会按照元素的升序进行排序\n升级，当插入一个超过当前编码范围的整数时，intset会升级\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e/* 编码方式，支持16位，32位，64位整数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunit32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e/* 元素个数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e/* 整数数组，保存集合数据 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003econtents数组存储的元素本身\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-intset的结构\"\u003e2 intset的结构\u003c/h1\u003e\n\u003cp\u003e为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\u003c/p\u003e\n\u003cp\u003e![[intset的结构.png]]\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组\u003c/li\u003e\n\u003cli\u003e倒序依次将数组中的元素拷贝到扩容后的正确位置\u003c/li\u003e\n\u003cli\u003e将待添加的元素放到数组的末尾\u003c/li\u003e\n\u003cli\u003e最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eintset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eintsetAdd\u003c/span\u003e(intset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eis, \u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e value, \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e valenc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_intsetValueEncoding\u003c/span\u003e(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e pos;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (valenc \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintre32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e encoding)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetUpgradeAndAdd\u003c/span\u003e(is, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eintsetSearch\u003c/span\u003e(is, value, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003epos)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tis \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetResize\u003c/span\u003e(is, \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (pos \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length)) \u003cspan style=\"color:#a6e22e\"\u003eintsetMoveTail\u003c/span\u003e(is, pos, pos \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e_intsetSet\u003c/span\u003e(is, pos, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tis \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003elength) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"4-应用场景\"\u003e4 应用场景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构\nset-max-intset-entries 512\nredis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\u003cp\u003eIntSet可以看作是特殊的整数数组，具备一些特点\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"1 概述 intSet数据结构的出现是用来存储整数类型的数据的 intSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量 有序，intset会按照元素的升序进行排序 升级，当插入一个超过当前编码范围的整数时，intset会升级\ntypedef struct intset { uint32_t encoding; /* 编码方式，支持16位，32位，64位整数 */ unit32_t length; /* 元素个数 */ int8_t contents[]; /* 整数数组，保存集合数据 */ } intset; contents数组存储的元素本身\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) 2 intset的结构 为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\n现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"1-概述\"\u003e1 概述\u003c/h1\u003e\n\u003cp\u003eintSet数据结构的出现是用来存储整数类型的数据的\nintSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量\n有序，intset会按照元素的升序进行排序\n升级，当插入一个超过当前编码范围的整数时，intset会升级\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e/* 编码方式，支持16位，32位，64位整数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunit32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e/* 元素个数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e/* 整数数组，保存集合数据 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003econtents数组存储的元素本身\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-intset的结构\"\u003e2 intset的结构\u003c/h1\u003e\n\u003cp\u003e为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组\u003c/li\u003e\n\u003cli\u003e倒序依次将数组中的元素拷贝到扩容后的正确位置\u003c/li\u003e\n\u003cli\u003e将待添加的元素放到数组的末尾\u003c/li\u003e\n\u003cli\u003e最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eintset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eintsetAdd\u003c/span\u003e(intset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eis, \u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e value, \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e valenc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_intsetValueEncoding\u003c/span\u003e(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e pos;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (valenc \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintre32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e encoding)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetUpgradeAndAdd\u003c/span\u003e(is, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eintsetSearch\u003c/span\u003e(is, value, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003epos)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tis \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetResize\u003c/span\u003e(is, \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (pos \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length)) \u003cspan style=\"color:#a6e22e\"\u003eintsetMoveTail\u003c/span\u003e(is, pos, pos \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e_intsetSet\u003c/span\u003e(is, pos, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tis \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003elength) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"4-应用场景\"\u003e4 应用场景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构\nset-max-intset-entries 512\nredis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\u003cp\u003eIntSet可以看作是特殊的整数数组，具备一些特点\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"1 概述 intSet数据结构的出现是用来存储整数类型的数据的 intSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量 有序，intset会按照元素的升序进行排序 升级，当插入一个超过当前编码范围的整数时，intset会升级\ntypedef struct intset { uint32_t encoding; /* 编码方式，支持16位，32位，64位整数 */ unit32_t length; /* 元素个数 */ int8_t contents[]; /* 整数数组，保存集合数据 */ } intset; contents数组存储的元素本身\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) 2 intset的结构 为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\n现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"1-概述\"\u003e1 概述\u003c/h1\u003e\n\u003cp\u003eintSet数据结构的出现是用来存储整数类型的数据的\nintSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量\n有序，intset会按照元素的升序进行排序\n升级，当插入一个超过当前编码范围的整数时，intset会升级\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e/* 编码方式，支持16位，32位，64位整数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunit32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e/* 元素个数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e/* 整数数组，保存集合数据 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003econtents数组存储的元素本身\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-intset的结构\"\u003e2 intset的结构\u003c/h1\u003e\n\u003cp\u003e为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组\u003c/li\u003e\n\u003cli\u003e倒序依次将数组中的元素拷贝到扩容后的正确位置\u003c/li\u003e\n\u003cli\u003e将待添加的元素放到数组的末尾\u003c/li\u003e\n\u003cli\u003e最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eintset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eintsetAdd\u003c/span\u003e(intset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eis, \u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e value, \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e valenc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_intsetValueEncoding\u003c/span\u003e(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e pos;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (valenc \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintre32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e encoding)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetUpgradeAndAdd\u003c/span\u003e(is, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eintsetSearch\u003c/span\u003e(is, value, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003epos)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tis \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetResize\u003c/span\u003e(is, \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (pos \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length)) \u003cspan style=\"color:#a6e22e\"\u003eintsetMoveTail\u003c/span\u003e(is, pos, pos \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e_intsetSet\u003c/span\u003e(is, pos, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tis \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003elength) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"4-应用场景\"\u003e4 应用场景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构\nset-max-intset-entries 512\nredis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\u003cp\u003eIntSet可以看作是特殊的整数数组，具备一些特点\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"1 概述 IntSet数据结构的出现是用来存储整数类型的数据。 IntSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量 有序，intset会按照元素的升序进行排序 升级，当插入一个超过当前编码范围的整数时，intset会升级\ntypedef struct intset { uint32_t encoding; /* 编码方式，支持16位，32位，64位整数 */ unit32_t length; /* 元素个数 */ int8_t contents[]; /* 整数数组，保存集合数据 */ } intset; contents数组存储的元素本身\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) 2 intset的结构 为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\n现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"1-概述\"\u003e1 概述\u003c/h1\u003e\n\u003cp\u003eIntSet数据结构的出现是用来存储整数类型的数据。\nIntSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量\n有序，intset会按照元素的升序进行排序\n升级，当插入一个超过当前编码范围的整数时，intset会升级\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e/* 编码方式，支持16位，32位，64位整数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunit32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e/* 元素个数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e/* 整数数组，保存集合数据 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003econtents数组存储的元素本身\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-intset的结构\"\u003e2 intset的结构\u003c/h1\u003e\n\u003cp\u003e为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组\u003c/li\u003e\n\u003cli\u003e倒序依次将数组中的元素拷贝到扩容后的正确位置\u003c/li\u003e\n\u003cli\u003e将待添加的元素放到数组的末尾\u003c/li\u003e\n\u003cli\u003e最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eintset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eintsetAdd\u003c/span\u003e(intset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eis, \u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e value, \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e valenc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_intsetValueEncoding\u003c/span\u003e(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e pos;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (valenc \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintre32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e encoding)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetUpgradeAndAdd\u003c/span\u003e(is, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eintsetSearch\u003c/span\u003e(is, value, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003epos)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tis \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetResize\u003c/span\u003e(is, \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (pos \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length)) \u003cspan style=\"color:#a6e22e\"\u003eintsetMoveTail\u003c/span\u003e(is, pos, pos \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e_intsetSet\u003c/span\u003e(is, pos, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tis \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003elength) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"4-应用场景\"\u003e4 应用场景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构\nset-max-intset-entries 512\nredis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\u003cp\u003eIntSet可以看作是特殊的整数数组，具备一些特点\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"1 概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。 IntSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量 有序，intset会按照元素的升序进行排序 升级，当插入一个超过当前编码范围的整数时，intset会升级\ntypedef struct intset { uint32_t encoding; /* 编码方式，支持16位，32位，64位整数 */ unit32_t length; /* 元素个数 */ int8_t contents[]; /* 整数数组，保存集合数据 */ } intset; contents数组存储的元素本身\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) 2 intset的结构 为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\n现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"1-概述\"\u003e1 概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量\n有序，intset会按照元素的升序进行排序\n升级，当插入一个超过当前编码范围的整数时，intset会升级\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e/* 编码方式，支持16位，32位，64位整数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunit32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e/* 元素个数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e/* 整数数组，保存集合数据 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003econtents数组存储的元素本身\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-intset的结构\"\u003e2 intset的结构\u003c/h1\u003e\n\u003cp\u003e为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组\u003c/li\u003e\n\u003cli\u003e倒序依次将数组中的元素拷贝到扩容后的正确位置\u003c/li\u003e\n\u003cli\u003e将待添加的元素放到数组的末尾\u003c/li\u003e\n\u003cli\u003e最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eintset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eintsetAdd\u003c/span\u003e(intset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eis, \u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e value, \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e valenc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_intsetValueEncoding\u003c/span\u003e(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e pos;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (valenc \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintre32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e encoding)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetUpgradeAndAdd\u003c/span\u003e(is, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eintsetSearch\u003c/span\u003e(is, value, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003epos)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tis \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetResize\u003c/span\u003e(is, \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (pos \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length)) \u003cspan style=\"color:#a6e22e\"\u003eintsetMoveTail\u003c/span\u003e(is, pos, pos \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e_intsetSet\u003c/span\u003e(is, pos, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tis \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003elength) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"4-应用场景\"\u003e4 应用场景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构\nset-max-intset-entries 512\nredis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\u003cp\u003eIntSet可以看作是特殊的整数数组，具备一些特点\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"1 概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; /* 编码方式，支持16位，32位，64位整数 */ unit32_t length; /* 元素个数 */ int8_t contents[]; /* 整数数组，保存集合数据 */ } intset; contents数组存储的元素本身\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) IntSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量 有序，intset会按照元素的升序进行排序 升级，当插入一个超过当前编码范围的整数时，intset会升级\n2 intset的结构 为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\n现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"1-概述\"\u003e1 概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e/* 编码方式，支持16位，32位，64位整数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunit32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e/* 元素个数 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e/* 整数数组，保存集合数据 */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003econtents数组存储的元素本身\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIntSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量\n有序，intset会按照元素的升序进行排序\n升级，当插入一个超过当前编码范围的整数时，intset会升级\u003c/p\u003e\n\u003ch1 id=\"2-intset的结构\"\u003e2 intset的结构\u003c/h1\u003e\n\u003cp\u003e为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组\u003c/li\u003e\n\u003cli\u003e倒序依次将数组中的元素拷贝到扩容后的正确位置\u003c/li\u003e\n\u003cli\u003e将待添加的元素放到数组的末尾\u003c/li\u003e\n\u003cli\u003e最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eintset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eintsetAdd\u003c/span\u003e(intset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eis, \u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e value, \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e valenc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_intsetValueEncoding\u003c/span\u003e(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e pos;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (valenc \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintre32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e encoding)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetUpgradeAndAdd\u003c/span\u003e(is, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eintsetSearch\u003c/span\u003e(is, value, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003epos)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tis \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetResize\u003c/span\u003e(is, \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (pos \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length)) \u003cspan style=\"color:#a6e22e\"\u003eintsetMoveTail\u003c/span\u003e(is, pos, pos \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e_intsetSet\u003c/span\u003e(is, pos, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tis \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003elength) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"4-应用场景\"\u003e4 应用场景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构\nset-max-intset-entries 512\nredis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\u003cp\u003eIntSet可以看作是特殊的整数数组，具备一些特点\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long unit32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; contents数组存储的元素本身\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) IntSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量 有序，intset会按照元素的升序进行排序 升级，当插入一个超过当前编码范围的整数时，intset会升级\n2 intset的结构 为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\n现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eunit32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003econtents数组存储的元素本身\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIntSet具有多重编码方式，能够存储16位，32位，64位的整数，对应Java的short、int、long类型的变量\n有序，intset会按照元素的升序进行排序\n升级，当插入一个超过当前编码范围的整数时，intset会升级\u003c/p\u003e\n\u003ch1 id=\"2-intset的结构\"\u003e2 intset的结构\u003c/h1\u003e\n\u003cp\u003e为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组\u003c/li\u003e\n\u003cli\u003e倒序依次将数组中的元素拷贝到扩容后的正确位置\u003c/li\u003e\n\u003cli\u003e将待添加的元素放到数组的末尾\u003c/li\u003e\n\u003cli\u003e最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eintset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eintsetAdd\u003c/span\u003e(intset \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eis, \u003cspan style=\"color:#66d9ef\"\u003eint64_t\u003c/span\u003e value, \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e valenc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_intsetValueEncoding\u003c/span\u003e(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e pos;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (valenc \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintre32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e encoding)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetUpgradeAndAdd\u003c/span\u003e(is, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eintsetSearch\u003c/span\u003e(is, value, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003epos)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (success) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esuccess \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tis \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintsetResize\u003c/span\u003e(is, \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (pos \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length)) \u003cspan style=\"color:#a6e22e\"\u003eintsetMoveTail\u003c/span\u003e(is, pos, pos \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e_intsetSet\u003c/span\u003e(is, pos, value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tis \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e length \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eintrev32ifbe\u003c/span\u003e(is\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003elength) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e is;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"4-应用场景\"\u003e4 应用场景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构\nset-max-intset-entries 512\nredis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\u003cp\u003eIntSet可以看作是特殊的整数数组，具备一些特点\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003cp\u003e现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\nencoding: 4字节 length：4字节 contents：2字节 * 3 = 6字节 指针是一个8字节大小的无符号整数 数组内容的寻址公式 startPtr + (sizeof(int16) * index) 其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节 3 intset升级流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eencoding: 4字节\u003c/li\u003e\n\u003cli\u003elength：4字节\u003c/li\u003e\n\u003cli\u003econtents：2字节 * 3 = 6字节\n指针是一个8字节大小的无符号整数\n数组内容的寻址公式\n\u003ccode\u003estartPtr + (sizeof(int16) * index)\u003c/code\u003e\n其中sizeof函数返回的是字节数，int16数据结构为16个bit，也就是2个字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"3-intset升级流程\"\u003e3 intset升级流程\u003c/h1\u003e\n\u003cp\u003e现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节\n我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个intset，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，intset会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 获取 IntSet 当前的 encoding uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intre32ifbe(is -\u0026gt; encoding)) { return intsetUpgradeAndAdd(is, value); } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { if (success) *success = 0; return is; } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; if (success) *success = 1; if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找，这里 if (success) *success = 0; return is; // 找得到就直接返回了 } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的 if (success) *success = 1; if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找，这里 if (success) *success = 0; return is; // 找得到就直接返回了 } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找，这里 if (success) *success = 0; return is; // 找得到就直接返回了 } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找，这里 if (success) *success = 0; return is; // 找得到就直接返回了 } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1， if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找，这里 if (success) *success = 0; return is; // 找得到就直接返回了 } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } _intsetSet(is, pos, value); is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 自动升级的流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); uint8_t newenc = _intsetValueEncoding(value); int length = intrev32ifbe(is-\u0026gt;length); int prepend = value \u0026lt; 0 ? 1 : 0; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1) } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length // 如果为负数，prepend 为 1，表示新元素应该插入到集合头部；否则为 0，表示插入到集合尾部 int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length // 如果为负数，prepend 为 1，表示新元素应该插入到集合头部；否则为 0，表示插入到集合尾部 int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); // 重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length // 如果为负数，prepend 为 1，表示新元素应该插入到集合头部；否则为 0，表示插入到集合尾部 int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); // 重新分配集合的内存，使其能够容纳一个额外的元素· is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length // 如果为负数，prepend 为 1，表示新元素应该插入到集合头部；否则为 0，表示插入到集合尾部 int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); // 重新分配集合的内存，使其能够容纳一个额外的元素· is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); while (length--) _intsetSet(is, length + prepend, _insetGetEncoded(is, length, curenc)); if (prepend) _intsetSet(is, 0, value); else _intsetSet(is, intrev32ifbe(is-\u0026gt;length)) } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length // 如果为负数，prepend 为 1，表示新元素应该插入到集合头部；否则为 0，表示插入到集合尾部 int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); // 重新分配集合的内存，使其能够容纳一个额外的元素· is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); while (length--) _intsetSet(is, length + prepend, _insetGetEncoded(is, length, curenc)); if (prepend) _intsetSet(is, 0, value); else _intsetSet(is, intrev32ifbe(is-\u0026gt;length),value); is-\u0026gt;length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length // 如果为负数，prepend 为 1，表示新元素应该插入到集合头部；否则为 0，表示插入到集合尾部 int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); // 重新分配集合的内存，使其能够容纳一个额外的元素· is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); while (length--) _intsetSet(is, length + prepend, _insetGetEncoded(is, length, curenc)); if (prepend) // 根据 prepend 的值决定将新元素插入到头部还是尾部 _intsetSet(is, 0, value); else _intsetSet(is, intrev32ifbe(is-\u0026gt;length),value); // 更新 intset 的元素长度 is-\u0026gt;length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length // 如果为负数，prepend 为 1，表示新元素应该插入到集合头部；否则为 0，表示插入到集合尾部 int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); // 重新分配集合的内存，使其能够容纳一个额外的元素· is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); while (length--) // _intsetSet(is, length + prepend, _insetGetEncoded(is, length, curenc)); if (prepend) // 根据 prepend 的值决定将新元素插入到头部还是尾部 _intsetSet(is, 0, value); else _intsetSet(is, intrev32ifbe(is-\u0026gt;length),value); // 更新 intset 的元素长度 is-\u0026gt;length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length // 如果为负数，prepend 为 1，表示新元素应该插入到集合头部；否则为 0，表示插入到集合尾部 int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); // 重新分配集合的内存，使其能够容纳一个额外的元素· is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); while (length--) // _insetGetEncoded根据旧编码方式获取元素位置 // _intsetSet根据新编码方式插入到新位置 _intsetSet(is, length + prepend, _insetGetEncoded(is, length, curenc)); if (prepend) // 根据 prepend 的值决定将新元素插入到头部还是尾部 _intsetSet(is, 0, value); else _intsetSet(is, intrev32ifbe(is-\u0026gt;length),value); // 更新 intset 的元素长度 is-\u0026gt;length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在一定条件下底层使用的是intset。set是一种无序的、不能包含重复元素的数据结构，用于存储多个元素。当set中存储的元素都是整数，并且元素个数较少的时候，redis会使用intset作为底层存储的数据结构 set-max-intset-entries 512 redis 默认配置 intset 的最大存储容量为 512，超过这个数量 redis 会将 intset 变为哈希 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length // 如果为负数，prepend 为 1，表示新元素应该插入到集合头部；否则为 0，表示插入到集合尾部 int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); // 重新分配集合的内存，使其能够容纳一个额外的元素· is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); while (length--) // _insetGetEncoded根据旧编码方式获取元素位置 // _intsetSet根据新编码方式插入到新位置 _intsetSet(is, length + prepend, _insetGetEncoded(is, length, curenc)); if (prepend) // 根据 prepend 的值决定将新元素插入到头部还是尾部 _intsetSet(is, 0, value); else _intsetSet(is, intrev32ifbe(is-\u0026gt;length),value); // 更新 intset 的元素长度 is-\u0026gt;length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在只存储少量整数的情况下使用的是 IntSet 编码 通过配置set-max-intset-entries 512可以控制 IntSet 存储的最大元素数量 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"},{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java 栈帧"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis 网络模型"},{"content":"概述 在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\nIntSet 的数据结构 typedef struct intset { uint32_t encoding; // 编码方式，支持16位，32位，64位整数，对应 short、int、long uint32_t length; // 元素个数 int8_t contents[]; // 整数数组，保存集合数据 } intset; encoding：表示 IntSet 的编码方式，它决定了contents数组中每个元素的类型。Redis 支持三种长度的编码 #define INTSET_ENC_INT16 (sizeof(int16_t)) // 相当于 java short #define INTSET_ENC_INT32 (sizeof(int32_t)) // 相当于 java int #define INTSET_ENC_INT64 (sizeof(int64_t)) // 相当于 java long length：表示IntSet 中实际存储的元素的个数 contents：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找 IntSet 的主要特点 内存紧凑 假如 IntSet 的encoding 是 INTSET_ENC_INT16，那么数组中每个数字占用的大小都是 16 位，两个字节\n文件头占用的大小为 encoding（4 字节） + length （4 字节）\n有序存储 元素在contents数组中按照从小到大的顺序排列，这样能够使用二分查找进行数据查询，时间复杂度为 O(logn)\n自动升级 每次插入一个新元素，而该新元素无法使用当前编码方式表示的时候，IntSet 会进行自动升级操作，以容纳新元素\nIntSet 添加元素的流程 首先比对要插入的元素的 encoding 与当前 encoding，视情况是否扩容 进行二分查找，如果找到元素则返回；如果未找到元素则判断元素添加的位置，视情况腾出位置给元素 插入元素 更新IntSet 的长度，返回 // intset.c intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); // 计算要添加的整数所需要的 encoding uint32_t pos; // 记录新纪录要插入的位置 if (success) *success = 1; // 如果传入了 success 指针，则将其初始化为 1，表示添加操作默认为成功 if (valenc \u0026gt; intrev32ifbe(is -\u0026gt; encoding)) { // 如果大于 IntSet 现在的 encoding return intsetUpgradeAndAdd(is, value); // 执行 IntSet 升级 } else { if (intsetSearch(is, value, \u0026amp;pos)) { // 进行二分查找 if (success) *success = 0; // 找到了元素，success为0表示添加操作失败 return is; // 返回 intset } // 如果值不存在，则需要为元素分配新空间 // intSetResize 函数会重新分配集合的内存，使其能够容纳一个额外的元素 is = intsetResize(is, intrev32ifbe(is -\u0026gt; length) + 1); // 如果插入的位置不在集合的末尾，需要将插入位置之后的元素向后移动一位，腾出位置 if (pos \u0026lt; intrev32ifbe(is -\u0026gt; length)) intsetMoveTail(is, pos, pos + 1); } // 将新元素插入到指定位置 _intsetSet(is, pos, value); // 更新集合的长度 is -\u0026gt; length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); // 返回修改后的整数集合指针 return is; } IntSet 的升级流程 现在，假设有一个IntSet，元素为{5, 10, 20}，采用的编码是INTSET_ENC_INT16，则每个整数占2个字节 我们向该数组中添加一个数字，50000，这个数字的大小超过了int_16的范围，IntSet会自动升级编码方式到合适的大小\n升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式以及元素个数扩容数组 倒序依次将数组中的元素拷贝到扩容后的正确位置 将待添加的元素放到数组的末尾 最后修改头信息，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4 // intset.c static intset *insetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u0026gt;encoding); // 计算出当前 encoding uint8_t newenc = _intsetValueEncoding(value); // 计算出新的 encoding int length = intrev32ifbe(is-\u0026gt;length); // 计算出当前的 length // 如果为负数，prepend 为 1，表示新元素应该插入到集合头部；否则为 0，表示插入到集合尾部 int prepend = value \u0026lt; 0 ? 1 : 0; // 设置 intset 结构体的 encoding 为新的 encoding is-\u0026gt;encoding = intrev32ifbe(newenc); // 重新分配集合的内存，使其能够容纳一个额外的元素· is = intsetResize(is, intrev32ifbe(is-\u0026gt;length) + 1); while (length--) // _insetGetEncoded根据旧编码方式获取元素位置 // _intsetSet根据新编码方式插入到新位置 _intsetSet(is, length + prepend, _insetGetEncoded(is, length, curenc)); if (prepend) // 根据 prepend 的值决定将新元素插入到头部还是尾部 _intsetSet(is, 0, value); else _intsetSet(is, intrev32ifbe(is-\u0026gt;length),value); // 更新 intset 的元素长度 is-\u0026gt;length = intrev32ifbe(intrev32ifbe(is-\u0026gt;length) + 1); return is; } 4 应用场景 在redis中，set集合数据结构在只存储少量整数的情况下使用的是 IntSet 编码 通过配置set-max-intset-entries 512可以控制 IntSet 存储的最大元素数量 可以通过 object encoding [key] 命令查看元素的 encoding 如果往set 添加了字符串，在 redis8.0 中，encoding 会变成 listpack 5 总结 IntSet可以看作是特殊的整数数组，具备一些特点\nredis会确保intset中的元素唯一，有序 具备类型升级机制，可以节省内存空间 数据按照从小到大的顺序存放 底层采用二分查找的方式来查询 ","permalink":"http://localhost:1313/posts/redis-encoding-intset/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e在 Redis中，IntSet（整数集合）是一种用来保存整数值集合的抽象数据结构，当一个集合只包含整数值元素，并且元素数量不多的时候，Redis 就会用 IntSet 来存储该集合。\u003c/p\u003e\n\u003ch1 id=\"intset-的数据结构\"\u003eIntSet 的数据结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e intset {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e encoding; \u003cspan style=\"color:#75715e\"\u003e// 编码方式，支持16位，32位，64位整数，对应 short、int、long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e length; \u003cspan style=\"color:#75715e\"\u003e// 元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eint8_t\u003c/span\u003e contents[]; \u003cspan style=\"color:#75715e\"\u003e// 整数数组，保存集合数据\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} intset; \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eencoding\u003c/code\u003e：表示 IntSet 的编码方式，它决定了\u003ccode\u003econtents\u003c/code\u003e数组中每个元素的类型。Redis 支持三种长度的编码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT16 (sizeof(int16_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java short\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT32 (sizeof(int32_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java int\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define INTSET_ENC_INT64 (sizeof(int64_t)) \u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e// 相当于 java long\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elength\u003c/code\u003e：表示IntSet 中实际存储的元素的个数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtents\u003c/code\u003e：是一个整数数组，数组中的元素按照从小到大的顺序进行排列，这样可以方便进行二分查找\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"intset的结构\" loading=\"lazy\" src=\"/posts/redis-encoding-intset/images/intset%E7%9A%84%E7%BB%93%E6%9E%84.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"intset-的主要特点\"\u003eIntSet 的主要特点\u003c/h1\u003e\n\u003ch2 id=\"内存紧凑\"\u003e内存紧凑\u003c/h2\u003e\n\u003cp\u003e假如 IntSet 的encoding 是 \u003ccode\u003eINTSET_ENC_INT16\u003c/code\u003e，那么数组中每个数字占用的大小都是 16 位，两个字节\u003c/p\u003e\n\u003cp\u003e文件头占用的大小为 encoding（4 字节） + length （4 字节）\u003c/p\u003e","title":"Redis 数据编码 IntSet"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 假设我们创建一个4 个字符的字符串 name，该字符串在内存中的结构如下：\nlen：表示字符串的长度为 4\nalloc：表示为 buf 分配的内存空间为 4，不包含结束标识\nflag：表示该字符串编码为 SDS_TYPE_8\n其后跟随的是 buf 数组的实际存储内容\nSDS动态扩容 假设现在有一个字符串 hi\n我们需要修改其字符串的内容，添加上,amy，那么这里首先会申请新的内容空间，申请大小为新的字符串长度 * 2 + 1，也就是 6 * 2 + 1 = 13\nSDS 的动态扩容规则\n如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"}]