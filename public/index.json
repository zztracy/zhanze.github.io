[{"content":" 定义 栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\n组成部分 局部变量表（Local Variable Table） 存储内容：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 int、double、boolean 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。 索引方式：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 this 引用，表示当前对象的引用；对于静态方法，则没有 this 引用。例如，在下面的 Java 方法中： public class Example { public void instanceMethod(int param1, String param2) { int localVar = 10; // ... } public static void staticMethod(int param) { double localVar = 3.14; // ... } } 在 instanceMethod 方法的局部变量表中，索引 0 存储 this 引用，索引 1 存储 param1，索引 2 存储 param2，索引 3 存储 localVar；在 staticMethod 方法的局部变量表中，索引 0 存储 param，索引 1 存储 localVar。\n操作数栈（Operand Stack） 存储中间结果：操作数栈是一个后进先出（LIFO）的栈结构，用于在方法执行过程中存储中间结果和操作数。在方法执行过程中，会将各种中间结果压入操作数栈，然后在需要时从操作数栈中弹出进行计算或其他操作。例如，在执行 a + b 时，会先将 a 和 b 的值从局部变量表中取出，压入操作数栈，然后进行加法运算，将结果再压入操作数栈。 栈深度动态变化：操作数栈的深度在方法执行过程中是动态变化的，其最大深度在编译时就已经确定。不同的字节码指令对操作数栈的操作不同，有些指令会将操作数压入栈中，有些指令会从栈中弹出操作数进行计算。 动态链接（Dynamic Linking） 符号引用解析：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在 Java 类文件中，方法调用和变量访问通常使用符号引用（如方法的全限定名、字段名等）来表示。动态链接的作用就是在运行时将这些符号引用解析为直接引用（如方法的实际内存地址、字段的实际内存位置）。 支持多态调用：动态链接使得 Java 能够实现多态调用。在运行时，根据实际对象的类型来确定调用的具体方法，而不是在编译时就确定。例如，通过父类引用调用子类重写的方法时，会在运行时根据实际对象的类型来解析方法的调用。 方法出口（Method Exit） 记录返回信息：方法出口记录了方法执行完毕后返回的位置信息。当一个方法执行完毕后，需要返回到调用该方法的位置继续执行，方法出口就记录了这个调用位置。方法出口有两种情况：正常返回和异常返回。正常返回时，会将方法的返回值压入调用该方法的栈帧的操作数栈中；异常返回时，会跳转到异常处理器进行处理。 栈帧创建与释放 栈帧的创建 方法调用触发栈帧创建 当 Java 程序执行到一个方法调用语句的时候，例如 methodA()调用 methodB()，就会出发 methodB 对应栈帧的创建。方法调用可以通过字节码指令（invokevirtual、invokespecial、invokestatic）来实现，不同的指令用于不同类型方法的调用\n分配栈帧的内存空间\n确定栈帧的大小：在创建栈帧之前，Java 虚拟机会根据方法的字节码信息来确定该栈帧所需的内存大小。这包括局部变量表的大小、操作数栈的最大深度等等 分配内存：Java 虚拟机会在当前线程的虚拟机栈中为新的栈帧分配相应大小的内存空间。 初始化栈帧组件\n局部变量表：将方法调用时传递的参数依次存储在局部变量表中，局部变量表中每个变量的大小在编译的过程中就确定了。 操作数栈：操作数栈在栈帧创建的时候会被初始化为空。操作数栈在方法执行过程中存储中间结果和操作数。 动态链接：符号引用解析（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在栈帧创建的时候，会对方法中的符号引用进行解析，将其转为直接引用。符号引用是在编译中的一种表示方式、字段等的引用方式，而直接引用则是指向实际内存地址的引用；建立链接（通过动态链接，栈帧可以在运行的时候找到被调用方法的实际代码位置，从而实现方法的动态调用。 方法出口：实际上就是调用该方法的语句的地址，我们在执行完当前方法后，就可以根据该地址返回到调用该方法的语句。 栈帧的释放 当满足栈帧释放的条件之后，会按照以下步骤进行释放\n返回值处理：如果方法有返回值，将会将返回值压入调用该方法的栈帧的操作数栈中 恢复上层方法的执行状态：从当前栈帧取出方法出口所记录的地址，程序计数器会被设置为该返回地址，这样程序就能回到调用该方法的位置继续执行代码 释放栈帧内存：将当前栈帧所占用的内存空间释放，包括局部变量表、操作数栈、动态链接等所占用的内存。此时，该栈帧从 Java 虚拟机栈弹出，虚拟机恢复到调用之前的状态。 ","permalink":"http://localhost:1313/posts/java-stack-frame/","summary":"\u003ch1 id=\"heading\"\u003e\u003c/h1\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e栈帧是 Java 虚拟机栈中的一个独立单元，每当一个方法被调用时，Java 虚拟机会为该方法创建一个对应的栈帧，并将其压入当前线程的虚拟机栈中。当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出并被销毁。每个线程都有自己独立的虚拟机栈，因此每个线程在执行方法时都会有自己的栈帧序列。\u003c/p\u003e\n\u003ch2 id=\"组成部分\"\u003e组成部分\u003c/h2\u003e\n\u003ch3 id=\"局部变量表local-variable-table\"\u003e局部变量表（Local Variable Table）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储内容\u003c/strong\u003e：局部变量表用于存储方法的参数和方法内部定义的局部变量。它是一个数组结构，每个元素可以存储一个基本数据类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003edouble\u003c/code\u003e、\u003ccode\u003eboolean\u003c/code\u003e 等）、一个引用类型（如对象引用、数组引用）或一个返回地址。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引方式\u003c/strong\u003e：局部变量通过索引来访问，索引从 0 开始。对于实例方法，局部变量表的第 0 个位置通常存储的是 \u003ccode\u003ethis\u003c/code\u003e 引用，表示当前对象的引用；对于静态方法，则没有 \u003ccode\u003ethis\u003c/code\u003e 引用。例如，在下面的 Java 方法中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eExample\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einstanceMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param1, String param2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estaticMethod\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e localVar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 3.\u003cspan style=\"color:#a6e22e\"\u003e14\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003einstanceMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003ethis\u003c/code\u003e 引用，索引 1 存储 \u003ccode\u003eparam1\u003c/code\u003e，索引 2 存储 \u003ccode\u003eparam2\u003c/code\u003e，索引 3 存储 \u003ccode\u003elocalVar\u003c/code\u003e；在 \u003ccode\u003estaticMethod\u003c/code\u003e 方法的局部变量表中，索引 0 存储 \u003ccode\u003eparam\u003c/code\u003e，索引 1 存储 \u003ccode\u003elocalVar\u003c/code\u003e。\u003c/p\u003e","title":"Java Stack Frame"},{"content":"概述 我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\n字符串长度的获取\nC 语言字符串：需要进行遍历运算，直到遇见'\\0'，时间复杂度 O(n) SDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1) 缓冲区溢出问题\nC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。 SDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险 内存分配效率\nC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销 SDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。 SDS 的结构 struct __attribute__ ((__packed__)) sdshdr8 { uint_t len; // 表示 buf 数组中保存的字符字节数，不包含结束标识 uint_t alloc; // 表示 buf 数组申请的总总字节数，不包含结束表示 unsigned char flags; // 不同 SDS 的头类型，用来控制 SDS 的大小 char buf[]; // 字符串的底层数组 } 属性 flags 的值是预定义好的宏\n#define SDS_TYPE_5 0 // 31 #define SDS_TYPE_8 1 // 255 #define SDS_TYPE_16 2 // 65535 #define SDS_TYPE_32 3 // 很长 #define SDS_TYPE_64 4 // 超级长 SDS动态扩容的规则 如果新字符串小于1M，则新空间为扩展后字符串的长度的两倍 + 1 如果新字符串大于1M，则新空间为扩展后的字符串的长度 + 1M + 1。称为内存预分配。内存预分配可以减少操作系统在用户态和内核态切换带来的消耗 ","permalink":"http://localhost:1313/posts/redis-encoding-sds/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003e我们知道 Redis 是基于 C 语言进行开发的，但是 Redis 字符串底层使用的却不是 C 语言的字符串数据结构，而是自己创建了一种数据结构称为 SDS（Simple Dynamic String，简单动态字符串），这是因为 C 语言的字符串存在许多问题，针对这些问题，Redis 自己定义了 SDS 来解决：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e字符串长度的获取\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：需要进行遍历运算，直到遇见\u003ccode\u003e'\\0'\u003c/code\u003e，时间复杂度 O(n)\u003c/li\u003e\n\u003cli\u003eSDS：在 SDS 的数据结构中，存在属性 len 记录着字符串的长度，时间复杂度 O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缓冲区溢出问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：由于 C 语言字符串不记录自身长度，在进行字符串拼接操作时，如果没有提前分配足够的内存，就容易发生缓冲区溢出。\u003c/li\u003e\n\u003cli\u003eSDS：SDS 在进行字符串修改操作的时候，会首先检查空间是否足够，如果空间不足够会自动进行扩容，避免缓冲区溢出的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内存分配效率\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 语言字符串：对 C 语言字符串进行修改时，每次可能都需要重新分配内存并且复制数据，频繁的内存分配和释放操作会带来较大的开销\u003c/li\u003e\n\u003cli\u003eSDS：SDS 采用了空间预分配策略。空间预分配是指在扩容的时候，除了分配所需要的空间，还会额外预先分配一些额外的空间，减少了后续操作时再次进行内存分配的概率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"sds-的结构\"\u003eSDS 的结构\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__attribute__\u003c/span\u003e ((__packed__)) sdshdr8 {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e len; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组中保存的字符字节数，不包含结束标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint_t\u003c/span\u003e alloc; \u003cspan style=\"color:#75715e\"\u003e// 表示 buf 数组申请的总总字节数，不包含结束表示\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e flags; \u003cspan style=\"color:#75715e\"\u003e// 不同 SDS 的头类型，用来控制 SDS 的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e buf[]; \u003cspan style=\"color:#75715e\"\u003e// 字符串的底层数组\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性 flags 的值是预定义好的宏\u003c/p\u003e","title":"Redis 数据编码 SDS"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ","permalink":"http://localhost:1313/posts/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e","title":"Redis Network Model"},{"content":"Redis 网络模型 https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\n1 Redis 网络模型 ![[Redis 网络模型.png]]\n2 Redis 6.0 启用了多线程 通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上 因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理 过程是这样的\n在 epoll_wait 的过程中遍历得到待处理的客户端 socket 一个客户端 socket 在一次请求中可能会传递多个命令 多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中 Redis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中 Redis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据 需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。 ![[Multiple threaded model in Redis.png]]\n","permalink":"http://localhost:1313/redis-network-model/","summary":"\u003ch1 id=\"redis-网络模型\"\u003eRedis 网络模型\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\"\u003ehttps://www.sobyte.net/post/2022-03/redis-multi-threaded-network-model/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"1-redis-网络模型\"\u003e1 Redis 网络模型\u003c/h1\u003e\n\u003cp\u003e![[Redis 网络模型.png]]\u003c/p\u003e\n\u003ch1 id=\"2-redis-60-启用了多线程\"\u003e2 Redis 6.0 启用了多线程\u003c/h1\u003e\n\u003cp\u003e通过对 Redis 的网络模型进行分析我们可以知道，Redis 网络模型的性能瓶颈在于（1）对客户端 socket 的 IO 解析；（2）对客户端 socket 的 IO 回写数据。 瓶颈都是出现在 IO 上\n因此，Redis 针对（1）客户端命令解析；（2）写响应结果这两个环节采用了多线程进行并发的处理\n过程是这样的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 epoll_wait 的过程中遍历得到待处理的客户端 socket\u003c/li\u003e\n\u003cli\u003e一个客户端 socket 在一次请求中可能会传递多个命令\u003c/li\u003e\n\u003cli\u003e多线程分配一个线程从这个客户端 socket 请求中解析命令，这一个特定线程解析完所有命令后会将结果依次添加到一个全局队列中\u003c/li\u003e\n\u003cli\u003eRedis 主线程从全局队列中依次执行，并且将结果写到 client 的响应缓冲区中\u003c/li\u003e\n\u003cli\u003eRedis 在下一次 epoll_wait 循环中监听到客户端 socket 的写事件就绪，再通过多线程的方式，每个 socket 分配一个线程进行串行的回写数据\n需要注意的是，Redis 开启多线程后不保证多个客户端之间命令的串行性，只保证单个客户端内部命令执行以及响应的串行性（通过为一个客户端分配一个单独的线程串行执行来完成），这种设计满足大部分场景的要求，因为客户端通常只关注自身操作的原子性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e![[Multiple threaded model in Redis.png]]\u003c/p\u003e","title":"Redis Network Model"},{"content":"Job Experience Backend Project Manager @ OHUP | Apr-2024 - Oct-2024 Back-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024 Technical Skills - Programming/ Scripting Languages : Java C JavaScript Bash - Operating Systems : Linux(CentOS) - SQL MySQL Redis - MiddleWare RabbitMQ Dubbo Zookeeper - Infra Docker K8s PC Configuration MacBook M1 2020\nDisk: 256GB RAM: 8G OS: MacOS Sonoma 14.5 Desktop\nCPU: AMD Ryzen5 5600G CPU @ 3.90GHz GPU: AMD Radeon Vega Graphics 7 Disk: 1T SSD RAM: 32GB OS: Windows 11 ","permalink":"http://localhost:1313/about/","summary":"\u003ch1 id=\"job-experience\"\u003eJob Experience\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBackend Project Manager @ OHUP | Apr-2024 - Oct-2024\u003c/li\u003e\n\u003cli\u003eBack-end Development Engineer@ FESCO.Adecco. | July-2021 - Mar-2024\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"technical-skills\"\u003eTechnical Skills\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- Programming/ Scripting Languages :\n\tJava\n\tC\n\tJavaScript\n\tBash\n- Operating Systems :\n\tLinux(CentOS)\n- SQL\n\tMySQL\n\tRedis\n- MiddleWare\n\tRabbitMQ\n\tDubbo\n\tZookeeper\n- Infra\n\tDocker\n\tK8s\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"pc-configuration\"\u003ePC Configuration\u003c/h1\u003e\n\u003cp\u003eMacBook M1 2020\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDisk: 256GB\nRAM: 8G\nOS: MacOS Sonoma 14.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDesktop\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCPU: AMD Ryzen5 5600G CPU @ 3.90GHz\nGPU: AMD Radeon Vega Graphics 7\nDisk: 1T SSD\nRAM: 32GB\nOS: Windows 11\n\u003c/code\u003e\u003c/pre\u003e","title":"About"}]